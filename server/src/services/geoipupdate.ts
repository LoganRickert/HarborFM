import { mkdtempSync, rmSync, writeFileSync } from "fs";
import { join } from "path";
import { tmpdir } from "os";
import { spawn } from "child_process";
import { assertResolvedPathUnder, getDataDir } from "./paths.js";
import {
  APP_NAME,
  GEOIP_CONF_FILENAME,
  GEOIP_EDITION_IDS,
  GEOIPUPDATE_PATH,
} from "../config.js";

/**
 * Resolve credentials by merging body values with fallback per field.
 * Use body value when provided and non-empty; otherwise use fallback for that field.
 * So e.g. submitting only account_id uses that account_id and the saved license key.
 */
function resolveCredentials(
  accountId: string | undefined,
  licenseKey: string | undefined,
  getFallback?: () => { accountId: string; licenseKey: string },
): { accountId: string; licenseKey: string } | null {
  const fallback = getFallback?.();
  const resolvedAccountId =
    (accountId != null && accountId.trim() !== "" ? accountId.trim() : null) ??
    fallback?.accountId ??
    "";
  const resolvedLicenseKey =
    (licenseKey != null && licenseKey !== "" ? licenseKey.trim() : null) ??
    fallback?.licenseKey ??
    "";
  if (!resolvedAccountId || !resolvedLicenseKey) return null;
  return { accountId: resolvedAccountId, licenseKey: resolvedLicenseKey };
}

/**
 * Test MaxMind credentials by running geoipupdate in a temporary directory.
 * Does not modify the real database directory.
 */
export function validateMaxMindCredentials(
  accountId?: string,
  licenseKey?: string,
  getFallback?: () => { accountId: string; licenseKey: string },
): Promise<{ ok: boolean; error?: string }> {
  const resolved = resolveCredentials(accountId, licenseKey, getFallback);
  if (!resolved) {
    return Promise.resolve({
      ok: false,
      error:
        "MaxMind Account ID and License Key are required (provide them in the request or save them in settings first).",
    });
  }

  const tmpDir = mkdtempSync(join(tmpdir(), "geoip-test-"));
  const confPath = join(tmpDir, GEOIP_CONF_FILENAME);
  const conf = [
    `# Generated by ${APP_NAME} - credential test`,
    `AccountID ${resolved.accountId}`,
    `LicenseKey ${resolved.licenseKey}`,
    `EditionIDs ${GEOIP_EDITION_IDS}`,
    `DatabaseDirectory ${tmpDir}`,
  ].join("\n");

  try {
    writeFileSync(confPath, conf, "utf8");
  } catch (err) {
    rmSync(tmpDir, { recursive: true, force: true });
    const msg = err instanceof Error ? err.message : String(err);
    return Promise.resolve({
      ok: false,
      error: `Failed to write config: ${msg}`,
    });
  }

  return new Promise((resolve) => {
    const child = spawn(GEOIPUPDATE_PATH, ["-f", confPath], {
      stdio: ["ignore", "pipe", "pipe"],
      env: { ...process.env, GEOIPUPDATE_DB_DIR: tmpDir },
    });

    let stderr = "";
    child.stderr?.on("data", (chunk: Buffer) => {
      stderr += chunk.toString();
    });

    const cleanup = () => {
      try {
        rmSync(tmpDir, { recursive: true, force: true });
      } catch {
        // ignore
      }
    };

    child.on("error", (err) => {
      cleanup();
      if ((err as NodeJS.ErrnoException).code === "ENOENT") {
        resolve({
          ok: false,
          error:
            "GeoIP Update is not installed. Install it from https://github.com/maxmind/geoipupdate/releases and ensure geoipupdate is on PATH.",
        });
      } else {
        resolve({ ok: false, error: (err as Error).message });
      }
    });

    child.on("close", (code) => {
      cleanup();
      if (code === 0) {
        resolve({ ok: true });
      } else {
        const msg =
          stderr.trim() || `geoipupdate exited with code ${code ?? "unknown"}`;
        resolve({ ok: false, error: msg });
      }
    });
  });
}

/**
 * Write a GeoIP.conf file for the GeoIP Update program and run geoipupdate
 * to download GeoLite2-Country and GeoLite2-City into the data directory.
 * Requires the geoipupdate binary to be installed (e.g. from
 * https://github.com/maxmind/geoipupdate/releases).
 *
 * Account ID and license key are optional; when either is omitted, getFallback is called
 * to supply saved credentials (e.g. from settings).
 *
 * @returns Promise that resolves to { ok: true } or { ok: false, error: string }
 */
export function runGeoIPUpdate(
  accountId?: string,
  licenseKey?: string,
  getFallback?: () => { accountId: string; licenseKey: string },
): Promise<{ ok: boolean; error?: string }> {
  const dataDir = getDataDir();
  const confPath = join(dataDir, GEOIP_CONF_FILENAME);

  const resolved = resolveCredentials(accountId, licenseKey, getFallback);
  if (!resolved) {
    return Promise.resolve({
      ok: false,
      error:
        "MaxMind Account ID and License Key are required (provide them in the request or save them in settings first).",
    });
  }

  const { accountId: aid, licenseKey: lkey } = resolved;

  try {
    assertResolvedPathUnder(confPath, dataDir);

    // GeoIP.conf format: AccountID, LicenseKey, EditionIDs, DatabaseDirectory
    const conf = [
      `# Generated by ${APP_NAME} - do not edit; overwritten when MaxMind settings are saved`,
      `AccountID ${aid}`,
      `LicenseKey ${lkey}`,
      `EditionIDs ${GEOIP_EDITION_IDS}`,
      `DatabaseDirectory ${dataDir}`,
    ].join("\n");

    writeFileSync(confPath, conf, "utf8");
  } catch (err) {
    const msg = err instanceof Error ? err.message : String(err);
    return Promise.resolve({
      ok: false,
      error: `Failed to write GeoIP.conf: ${msg}`,
    });
  }

  return new Promise((resolve) => {
    const child = spawn(GEOIPUPDATE_PATH, ["-f", confPath], {
      stdio: ["ignore", "pipe", "pipe"],
      env: { ...process.env, GEOIPUPDATE_DB_DIR: dataDir },
    });

    let stderr = "";

    child.stderr?.on("data", (chunk: Buffer) => {
      stderr += chunk.toString();
    });

    child.on("error", (err) => {
      if ((err as NodeJS.ErrnoException).code === "ENOENT") {
        resolve({
          ok: false,
          error:
            "GeoIP Update is not installed. Install it from https://github.com/maxmind/geoipupdate/releases and ensure geoipupdate is on PATH.",
        });
      } else {
        resolve({ ok: false, error: (err as Error).message });
      }
    });

    child.on("close", (code) => {
      if (code === 0) {
        resolve({ ok: true });
      } else {
        const msg =
          stderr.trim() || `geoipupdate exited with code ${code ?? "unknown"}`;
        resolve({ ok: false, error: msg });
      }
    });
  });
}
