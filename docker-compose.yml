# Harbor FM stack: app, reverse proxy (nginx or Caddy), Whisper ASR, Fail2Ban
#
# Set REVERSE_PROXY=nginx or REVERSE_PROXY=caddy in .env. Then start with:
#   docker compose --profile $REVERSE_PROXY up -d
#
# Nginx: set DOMAIN, CERTBOT_EMAIL. Get cert: docker compose run --rm certbot. Renew: docker compose run --rm certbot renew
# Caddy: set DOMAIN; Caddy obtains and renews TLS automatically (no certbot).
# Always run docker compose from the install directory (where .env lives). .env must set INSTALL_DIR to that directory's absolute path so nginx sites-enabled and volume bind mounts are correct.

services:
  harborfm:
    image: ghcr.io/loganrickert/harborfm:latest
    container_name: harborfm
    restart: unless-stopped
    environment:
      NODE_ENV: production
      PORT: "3001"
      DATA_DIR: /data
      SECRETS_DIR: /secrets
    volumes:
      - harborfm_data:/data
      - harborfm_secrets:/secrets
    networks:
      - internal
    healthcheck:
      test: ["CMD", "node", "-e", "require('http').get('http://127.0.0.1:3001/api/health', (r) => { process.exit(r.statusCode === 200 ? 0 : 1); }).on('error', () => process.exit(1));"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 15s
    # Not exposed to host; nginx or caddy proxies to this

  nginx:
    profiles: ["nginx"]
    image: nginx:alpine
    container_name: harborfm-nginx
    restart: unless-stopped
    # Public entrypoint: publishes 80/443, also on internal network to proxy to harborfm
    ports:
      - "80:80"
      - "443:443"
    environment:
      DOMAIN: ${DOMAIN:-localhost}
      CERTBOT_EMAIL: ${CERTBOT_EMAIL:-}
    volumes:
      - ./nginx/nginx-80-only.conf.template:/etc/nginx/nginx-80-only.conf.template:ro
      - ./nginx/nginx-full.conf.template:/etc/nginx/nginx-full.conf.template:ro
      - ./nginx/entrypoint.sh:/entrypoint.sh:ro
      - certbot_webroot:/var/www/certbot
      - certbot_certs:/etc/letsencrypt
      - nginx_logs:/var/log/nginx
      - nginx_sites_enabled:/etc/nginx/sites-enabled:ro
    entrypoint: ["/bin/sh", "/entrypoint.sh"]
    healthcheck:
      test: ["CMD", "curl", "-f", "http://127.0.0.1:80/nginx-health"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 5s
    depends_on:
      harborfm:
        condition: service_healthy
    networks:
      - internal

  caddy:
    profiles: ["caddy"]
    image: caddy:alpine
    container_name: harborfm-caddy
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    environment:
      DOMAIN: ${DOMAIN:-localhost}
    volumes:
      - ./caddy/Caddyfile:/etc/caddy/Caddyfile:ro
      - caddy_data:/data
      - caddy_config:/config
      - caddy_logs:/var/log/caddy
    healthcheck:
      test: ["CMD", "wget", "-q", "-O", "-", "http://127.0.0.1:80/caddy-health"]
      interval: 10s
      timeout: 5s
      retries: 3
      start_period: 5s
    depends_on:
      harborfm:
        condition: service_healthy
    networks:
      - internal

  # Not started by default (profile: cert). Only used with nginx. Initial cert: docker compose run --rm certbot
  # Renew (cron): docker compose run --rm certbot renew
  certbot:
    profiles: ["cert"]
    image: certbot/certbot
    container_name: harborfm-certbot
    restart: "no"
    volumes:
      - certbot_webroot:/var/www/certbot
      - certbot_certs:/etc/letsencrypt
    environment:
      DOMAIN: ${DOMAIN:-localhost}
      CERTBOT_EMAIL: ${CERTBOT_EMAIL:-}
    entrypoint: ["/bin/sh", "-c"]
    command:
      - |
        if [ -z "$${CERTBOT_EMAIL}" ] || [ "$${DOMAIN}" = "localhost" ]; then
          echo "Set DOMAIN and CERTBOT_EMAIL in .env to obtain certificates."
          echo "Then run: docker compose run --rm certbot"
          exit 0
        fi
        certbot certonly --webroot -w /var/www/certbot -d "$${DOMAIN}" \
          --email "$${CERTBOT_EMAIL}" --agree-tos --no-eff-email --non-interactive --keep-until-expiring
        exit $$?
    networks:
      - internal

  whisper:
    image: onerahmet/openai-whisper-asr-webservice:latest
    container_name: harborfm-whisper
    restart: unless-stopped
    environment:
      ASR_MODEL: base
      ASR_ENGINE: openai_whisper
    # No ports exposed to host; use from harborfm via service name (e.g. http://whisper:9000)
    volumes:
      - whisper_cache:/root/.cache
    networks:
      - internal

  fail2ban:
    image: crazymax/fail2ban:latest
    container_name: harborfm-fail2ban
    restart: unless-stopped
    network_mode: host
    # Bans must use DOCKER-USER chain so traffic to published 80/443 is actually blocked (see jail.d)
    cap_add:
      - NET_ADMIN
      - NET_RAW
    volumes:
      - ./fail2ban/filter.d:/etc/fail2ban/filter.d:ro
      - ./fail2ban/jail.d:/etc/fail2ban/jail.d:ro
      - nginx_logs:/var/log/nginx:ro
      - caddy_logs:/var/log/caddy:ro
    environment:
      TZ: ${TZ:-UTC}
      F2B_LOG_LEVEL: info

# Named volumes backed by ${INSTALL_DIR}/harborfm-docker-data/ (install.sh sets INSTALL_DIR in .env)
volumes:
  harborfm_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${INSTALL_DIR:-.}/harborfm-docker-data/data
  harborfm_secrets:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${INSTALL_DIR:-.}/harborfm-docker-data/secrets
  certbot_webroot:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${INSTALL_DIR:-.}/harborfm-docker-data/certbot/webroot
  certbot_certs:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${INSTALL_DIR:-.}/harborfm-docker-data/certbot/certs
  nginx_logs:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${INSTALL_DIR:-.}/harborfm-docker-data/nginx/logs
  nginx_sites_enabled:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${INSTALL_DIR:-.}/harborfm-docker-data/nginx/sites-enabled
  caddy_data:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${INSTALL_DIR:-.}/harborfm-docker-data/caddy/data
  caddy_config:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${INSTALL_DIR:-.}/harborfm-docker-data/caddy/config
  caddy_logs:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${INSTALL_DIR:-.}/harborfm-docker-data/caddy/logs
  whisper_cache:
    driver: local
    driver_opts:
      type: none
      o: bind
      device: ${INSTALL_DIR:-.}/harborfm-docker-data/whisper/cache

networks:
  internal:
    driver: bridge
